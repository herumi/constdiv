# constdiv
This is a PoC of constant integer division faster than compiler-generated code.

# Abstract
Let $M=2^{32}-1$ and $d \in [1, M]$.
To efficiently compute $x\texttt{//}d := \mathrm{floor}(x/d)$ for $x \in [0, M]$,
we can use integer constants $c$ and $a$ such that $x \texttt{//} d = (x \times c) \texttt{>>} a$ for all $x \in [0, M]$.
When $c$ is a 33-bit constant, existing compilers for x64/ARM64 use the method proposed in [GM95](https://dl.acm.org/doi/10.1145/178243.178249).
However, this method was designed for 32-bit CPUs and is not necessarily optimal for 64-bit CPUs.
We propose a method that runs faster than existing compilers on x64/ARM64.

# Introduction

For a given integer $d \in [1, M]$, constants $c$ and $a$ are determined by Theorem 1 (described later).
We classify into the following patterns based on $d$ and $c$. It is guaranteed that $c < 2^{33}$.

## When $d > (M+1)/2$
Since $x\texttt{//}d \in [0, 1]$, we return 0 if $x < d$, otherwise 1.

```cpp
uint32_t divd(uint32_t x) {
    return (x < d) ? 0 : 1;
}
```

## When $d=2^a$
We can simply perform a logical right shift of $x$ by $a$ bits.

```cpp
uint32_t divd(uint32_t x) {
    return x >> a;
}
```

## When $c$ fits in 32 bits
We use 32-bit Ã— 32-bit = 64-bit multiplication.

```cpp
uint32_t divd(uint32_t x) {
    uint64_t v = x * uint64_t(c);
    v >>= a;
    return uint32_t(v);
}
```

## When $c$ is 33 bits
This is the pattern we aim to improve in this work.
We found that existing compilers generate the following code:

```cpp
uint32_t divd_original(uint32_t x)
{
	uint64_t v = x * uint64_t(c & 0xffffffff);
	v >>= 32;
	uint32_t t = uint32_t(x) - uint32_t(v);
	t >>= 1;
	t += uint32_t(v);
	t >>= a - 33;
	return t;
}
```
We explain the intention of the code.
Since $c$ is 33 bits, we split it into the lower 32 bits $c_L$ and the upper 1 bit.

$$
c = 2^{32} + c_L.
$$
Since $x c = x 2^{32} + x c_L$, we first calculate $x c_L$.
Since we know that $a \ge 32$, we perform a 32-bit logical right shift first.
Let this be $v$. $v = (x c_L) \texttt{>>} 32$.
The desired value is $(x + v) \texttt{>>} (a-32) = ((x + v) \texttt{>>} 1) \texttt{>>} (a-33)$.
Here, we transform the expression for $(x + v) \texttt{>>} 1$ as follows to ensure intermediate values do not exceed 32 bits.

$$
(x + v)\texttt{>>}1 = (x - v + 2 v)\texttt{>>}1 = ((x-v)\texttt{>>}1) + v.
$$

Since $v$ is the upper 32 bits of $x c_L$, it is less than or equal to $x$. Therefore $x - v \ge 0$.
Thus, the right-hand side can be computed within the range of 32-bit unsigned integers without underflow or overflow.

## Our Approach


# Misc
The code generated by GCC, Clang, or Visual Studio for `x / 7` is as follows:

```cpp
const uint64_t u_ = 0x124924925;
const uint32_t a_ = 35;

uint32_t div7org(uint32_t x)
{
	uint64_t v = x * (u_ & 0xffffffff);
	v >>= 32;
	uint32_t xL = uint32_t(x) - uint32_t(v);
	xL >>= 1;
	xL += uint32_t(v);
	xL >>= 2;
	return xL;
}
```

This can be optimized for x64/ARM64 architectures as follows:

```cpp
uint32_t div7optimized(uint32_t x)
{
	uint64_t v = x * (u_ & 0xffffffff);
	v >>= 32;
	v += x;
	v >>= a_ - 32;
	return uint32_t(v);
}
```

# Background
M: integer >= 1.
d in [1, M]
take A >= d.
  c := (A + d - 1) // d.
  e := d c - A.
  M_d := M - ((M+1)%d).

Lemma.
1. By definition,
  0 <= e <= d-1 < A.
  M_d%d = d-1.
  d-1 <= M_d.
2. if e M_d < A, then e(d-1) < A = d c - e, so e < c.

Theorem
if e M_d < A, then x//d = (x c)//A for x in [0, M].

Proof
(q, r) := divmod(x, d). x = d q + r.
Then x c = d q c + r c = (A + e) q + r c = A q + (q e + r c).
y := q e + r c.
If 0 <= y < A, then q = (x c) // A.
So we prove that y < A if e M_d < A.
f(x) := dy = d q e + d r c = d q e + (A + e) r = (d q + r) e + r A = x e + r A.
So if max f(x) < d A, then max(y) = max f(x) / d < A.

e and A are constant values and >= 0, then arg_max f(x) = M_d or M.
i.e., (x, r) = (M_d, d-1) or (M, r0) where r0 := M % d.

Claim max f(x) = f(M_d) < d A.
case 1. M_d = M. then r0 = d-1. max f(x) = f(M_d) = M_d e + (d-1) A < A + (d-1) A = d A.
case 2. M_d < M. then r0 < d-1. max f(x) = max(f(M_d), f(M)).
M = M_d + 1 + r0.
f(M_d) - f(M) = (M_d e + (d-1)A) - (M e + r0 A) = (d-1 - r0) A - (r0 + 1)e
>(d-1 - (d-2)) A - ((d-2)+1)e = A - d e + e = d (c - e) > 0.
Then max f(x) = f(M_d) < d A.

This condition is the assumption of Thereom 1 in
"Integer division by constants: optimal bounds", Daniel Lemire, Colin Bartlett, Owen Kaser. 2021

